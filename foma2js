#!/usr/bin/env ruby
# coding: utf-8

require 'pry'
###################################################################
# Converts foma file to js array for use with Javascript runtime  #
# Outputs a js array of all the transitions, indexed in the       #
# input direction. This array can be passed to the js function    #
# foma_apply_down() in foma_apply_down.js for stand-alone         #
# transducer application.                                         #
#                                                                 #
# Usage: foma2js [-n array variable name] [file]                  #
# MH 20120127                                                     #
###################################################################

require 'zlib'

def parse(f, net_name)
  mode = :none
  version = nil
  numnets = 0
  pr = {}
  trans = {}
  sigma = []
  finals = []
  longestsymbollength = 0
  arrstate = nil # keep this state around when reading states

  gz = Zlib::GzipReader.new(f)

  gz.each_line do |l|
    l.chomp!

    case l
    when /##foma-net ([0-9]+\.[0-9]+)##/
      version = $1
      numnets += 1
      raise "Only one network per file supported" if numnets > 1
    when '##props##'
      mode = :props
    when '##sigma##'
      mode = :sigma
    when '##states##'
      mode = :states
    when '##end##'
      mode = :none
    else
      case mode
      when :props
        pr[:arity], pr[:arccount], pr[:statecount], pr[:linecount],
          pr[:finalcount], pr[:pathcount], pr[:is_deterministic],
          pr[:is_pruned], pr[:is_minimized], pr[:is_epsilon_free],
          pr[:is_loop_free], pr[:extras], pr[:name] = l.split ' '
      when :states
        # state in out target final
        transitions = l.split(' ').map(&:to_i)

        if transitions[0] == -1
        elsif transitions[1] == -1 and transitions.length == 4
          arrstate = transitions[0]
          arrfinal = transitions[3]
          finals[arrstate] = 1 if arrfinal == 1
        else
          case transitions.length
          when 5
            arrstate, arrin, arrout, arrtarget, arrfinal = *transitions
            finals[arrstate] = 1 if arrfinal == 1
          when 4
            arrstate, arrin, arrtarget, arrfinal = *transitions
            arrout = arrin
            finals[arrstate] = 1 if arrfinal == 1
          when 3
            arrin, arrout, arrtarget = *transitions
          when 2
            arrin, arrtarget = *transitions
            arrout = arrin
          else
            raise "Unknown state"
          end

          k = [arrstate, sigma[arrin]].join('|')
          trans[k] ||= []
          trans[k] << "{#{arrtarget}:'#{sigma[arrout]}'}"
        end
      when :sigma
        number, symbol = l.split ' '
        number = number.to_i

        symbol.gsub! '@_EPSILON_SYMBOL_@', ''
        symbol.gsub! '@_IDENTITY_SYMBOL_@', '@ID@'
        symbol.gsub! '@_UNKNOWN_SYMBOL_@', '@UN@'
        symbol.gsub! "'", "\\'"
        sigma[number] = symbol

        longestsymbollength = symbol.length if number > 2 and symbol.length > longestsymbollength
      when :none
        raise "Format error"
      end
    end
  end

  gz.close

  puts "var #{net_name} = new Object;"
  puts "#{net_name}.t = Array;"
  puts "#{net_name}.f = Array;"
  puts "#{net_name}.s = Array;"
  puts

  trans.each do |k, v|
    state, _in = k.split '|'
    _in.gsub! '@UN@', '@ID@' if _in
    state = 0 if state.nil?
    puts "#{net_name}.t[#{state} + '|' + '#{_in}'] = [#{v.join(',')}];"
  end

  finals.each_with_index do |s, i|
    puts "#{net_name}.f[#{i}] = 1;" if s
  end

  sigma.each_with_index do |s, i|
    next if i < 3 # ignore the first three
    puts "#{net_name}.s['#{s}'] = #{i};" unless sigma[i].nil?
  end

  puts "#{net_name}.maxlen = #{longestsymbollength} ;"
end

net_name = 'myNet'

case ARGV.first
when '-n'
  ARGV.shift
  net_name = ARGV.first
  ARGV.shift
when '-h', '--help', NilClass
  puts "Usage: foma2js [-n name] filename"
  exit 0
else
  File.open(ARGV.first) do |f|
    parse(f, net_name)
  end
end

exit 0
